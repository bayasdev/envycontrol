package main

import (
	"bufio"
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"io/fs"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"syscall"
)

const (
	VERSION = "3.5.2"

	// File paths
	CACHE_FILE_PATH      = "/var/cache/envycontrol/cache.json"
	BLACKLIST_PATH       = "/etc/modprobe.d/blacklist-nvidia.conf"
	UDEV_INTEGRATED_PATH = "/etc/udev/rules.d/50-remove-nvidia.rules"
	UDEV_PM_PATH         = "/etc/udev/rules.d/80-nvidia-pm.rules"
	XORG_PATH            = "/etc/X11/xorg.conf"
	EXTRA_XORG_PATH      = "/etc/X11/xorg.conf.d/10-nvidia.conf"
	MODESET_PATH         = "/etc/modprobe.d/nvidia.conf"
	SDDM_XSETUP_PATH     = "/usr/share/sddm/scripts/Xsetup"
	LIGHTDM_SCRIPT_PATH  = "/etc/lightdm/nvidia.sh"
	LIGHTDM_CONFIG_PATH  = "/etc/lightdm/lightdm.conf.d/20-nvidia.conf"
)

// File contents
const BLACKLIST_CONTENT = `# Automatically generated by EnvyControl

blacklist nouveau
blacklist nvidia
blacklist nvidia_drm
blacklist nvidia_uvm
blacklist nvidia_modeset
blacklist nvidia_current
blacklist nvidia_current_drm
blacklist nvidia_current_uvm
blacklist nvidia_current_modeset
blacklist i2c_nvidia_gpu
alias nouveau off
alias nvidia off
alias nvidia_drm off
alias nvidia_uvm off
alias nvidia_modeset off
alias nvidia_current off
alias nvidia_current_drm off
alias nvidia_current_uvm off
alias nvidia_current_modeset off
alias i2c_nvidia_gpu off
`

const UDEV_INTEGRATED = `# Automatically generated by EnvyControl

# Remove NVIDIA USB xHCI Host Controller devices, if present
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x0c0330", ATTR{power/control}="auto", ATTR{remove}="1"

# Remove NVIDIA USB Type-C UCSI devices, if present
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x0c8000", ATTR{power/control}="auto", ATTR{remove}="1"

# Remove NVIDIA Audio devices, if present
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x040300", ATTR{power/control}="auto", ATTR{remove}="1"

# Remove NVIDIA VGA/3D controller devices
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x03[0-9]*", ATTR{power/control}="auto", ATTR{remove}="1"
`

const UDEV_PM_CONTENT = `# Automatically generated by EnvyControl

# Remove NVIDIA USB xHCI Host Controller devices, if present
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x0c0330", ATTR{remove}="1"

# Remove NVIDIA USB Type-C UCSI devices, if present
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x0c8000", ATTR{remove}="1"

# Remove NVIDIA Audio devices, if present
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x040300", ATTR{remove}="1"

# Enable runtime PM for NVIDIA VGA/3D controller devices on driver bind
ACTION=="bind", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x030000", TEST=="power/control", ATTR{power/control}="auto"
ACTION=="bind", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x030200", TEST=="power/control", ATTR{power/control}="auto"

# Disable runtime PM for NVIDIA VGA/3D controller devices on driver unbind
ACTION=="unbind", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x030000", TEST=="power/control", ATTR{power/control}="on"
ACTION=="unbind", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x030200", TEST=="power/control", ATTR{power/control}="on"
`

const XORG_INTEL = `# Automatically generated by EnvyControl

Section "ServerLayout"
    Identifier "layout"
    Screen 0 "nvidia"
    Inactive "intel"
EndSection

Section "Device"
    Identifier "nvidia"
    Driver "nvidia"
    BusID "%s"
EndSection

Section "Screen"
    Identifier "nvidia"
    Device "nvidia"
    Option "AllowEmptyInitialConfiguration"
EndSection

Section "Device"
    Identifier "intel"
    Driver "modesetting"
EndSection

Section "Screen"
    Identifier "intel"
    Device "intel"
EndSection
`

const XORG_AMD = `# Automatically generated by EnvyControl

Section "ServerLayout"
    Identifier "layout"
    Screen 0 "nvidia"
    Inactive "amdgpu"
EndSection

Section "Device"
    Identifier "nvidia"
    Driver "nvidia"
    BusID "%s"
EndSection

Section "Screen"
    Identifier "nvidia"
    Device "nvidia"
    Option "AllowEmptyInitialConfiguration"
EndSection

Section "Device"
    Identifier "amdgpu"
    Driver "amdgpu"
EndSection

Section "Screen"
    Identifier "amd"
    Device "amdgpu"
EndSection
`

const EXTRA_XORG_CONTENT = `# Automatically generated by EnvyControl

Section "OutputClass"
    Identifier "nvidia"
    MatchDriver "nvidia-drm"
    Driver "nvidia"
`

const FORCE_COMP = ` + "```" + `   Option "ForceCompositionPipeline" "true"
` + "```" + `
const COOLBITS = ` + "```" + `    Option "Coolbits" "%d"
` + "```" + `
const MODESET_CONTENT = `# Automatically generated by EnvyControl

options nvidia-drm modeset=1
options nvidia NVreg_UsePageAttributeTable=1 NVreg_InitializeSystemMemoryAllocations=0
`

const MODESET_CURRENT_CONTENT = `# Automatically generated by EnvyControl

options nvidia-current-drm modeset=1
options nvidia-current NVreg_UsePageAttributeTable=1 NVreg_InitializeSystemMemoryAllocations=0
`

const MODESET_RTD3 = `# Automatically generated by EnvyControl

options nvidia-drm modeset=1
options nvidia "NVreg_DynamicPowerManagement=0x0%d"
options nvidia NVreg_UsePageAttributeTable=1 NVreg_InitializeSystemMemoryAllocations=0
`

const MODESET_CURRENT_RTD3 = `# Automatically generated by EnvyControl

options nvidia-current-drm modeset=1
options nvidia-current "NVreg_DynamicPowerManagement=0x0%d"
options nvidia-current NVreg_UsePageAttributeTable=1 NVreg_InitializeSystemMemoryAllocations=0
`

const SDDM_XSETUP_CONTENT = ` + "`" + `#!/bin/sh
# Xsetup - run as root before the login dialog appears

` + "`" + `
const LIGHTDM_CONFIG_CONTENT = `# Automatically generated by EnvyControl

[Seat:*]
display-setup-script=/etc/lightdm/nvidia.sh
`

const NVIDIA_XRANDR_SCRIPT = ` + "`" + `#!/bin/sh
# Automatically generated by EnvyControl

current=""

xrandr --setprovideroutputsource "%s" NVIDIA-0
xrandr --auto

for next in $(xrandr --listmonitors | grep -E " *[0-9]+:.*" | cut -d" " -f6); do
  [ -z "$current" ] && current=$next && continue
  xrandr --output "$current" --auto --output "$next" --auto --right-of "$current"
  current=$next
done
` + "`" + `
var (
	supportedModes           = []string{"integrated", "hybrid", "nvidia"}
	supportedDisplayManagers = []string{"gdm", "gdm3", "sddm", "lightdm"}
	rtd3Modes               = []int{0, 1, 2, 3}
	verbose                 bool
)

type Config struct {
	Mode               string
	DisplayManager     string
	ForceComp          bool
	Coolbits           *int
	RTD3               *int
	UseNvidiaCurrent   bool
	NvidiaGPUPCIBus    string // cached value
}

type CacheData struct {
	NvidiaGPUPCIBus string ` + "`" + `json:"nvidia_gpu_pci_bus"` + "`" + `
}

func main() {
	var (
		version      = flag.Bool("version", false, "Output the current version")
		versionShort = flag.Bool("v", false, "Output the current version")
		query        = flag.Bool("query", false, "Query the current graphics mode")
		queryShort   = flag.Bool("q", false, "Query the current graphics mode")
		switchMode   = flag.String("switch", "", "Switch the graphics mode (integrated, hybrid, nvidia)")
		switchShort  = flag.String("s", "", "Switch the graphics mode (integrated, hybrid, nvidia)")
		dm           = flag.String("dm", "", "Manually specify Display Manager (gdm, gdm3, sddm, lightdm)")
		forceComp    = flag.Bool("force-comp", false, "Enable ForceCompositionPipeline on Nvidia mode")
		coolbits     = flag.Int("coolbits", -1, "Enable Coolbits on Nvidia mode (default: 28)")
		rtd3         = flag.Int("rtd3", -1, "Setup RTD3 Power Management on Hybrid mode (0-3, default: 2)")
		useNvCurrent = flag.Bool("use-nvidia-current", false, "Use nvidia-current instead of nvidia")
		resetSddm    = flag.Bool("reset-sddm", false, "Restore default Xsetup file")
		reset        = flag.Bool("reset", false, "Revert changes made by EnvyControl")
		cacheCreate  = flag.Bool("cache-create", false, "Create cache (hybrid mode only)")
		cacheDelete  = flag.Bool("cache-delete", false, "Delete cache")
		cacheQuery   = flag.Bool("cache-query", false, "Show cache")
		verboseFlag  = flag.Bool("verbose", false, "Enable verbose mode")
	)

	flag.Parse()

	verbose = *verboseFlag

	if *version || *versionShort {
		fmt.Println(VERSION)
		return
	}

	if *query || *queryShort {
		mode := getCurrentMode()
		fmt.Println(mode)
		return
	}

	if *cacheCreate {
		assertRoot()
		createCacheFile()
		return
	}

	if *cacheDelete {
		assertRoot()
		deleteCacheFile()
		return
	}

	if *cacheQuery {
		showCacheFile()
		return
	}

	mode := *switchMode
	if mode == "" {
		mode = *switchShort
	}

	if mode != "" {
		assertRoot()
		config := &Config{
			Mode:             mode,
			DisplayManager:   *dm,
			ForceComp:        *forceComp,
			UseNvidiaCurrent: *useNvCurrent,
		}

		if *coolbits >= 0 {
			config.Coolbits = coolbits
		} else if *coolbits == -1 && *forceComp {
			// Default coolbits value when not specified but force-comp is used
			defaultCoolbits := 28
			config.Coolbits = &defaultCoolbits
		}

		if *rtd3 >= 0 {
			config.RTD3 = rtd3
		} else if *rtd3 == -1 && mode == "hybrid" {
			// Default RTD3 value when not specified in hybrid mode
			defaultRTD3 := 2
			config.RTD3 = &defaultRTD3
		}

		graphicsModeSwitcher(config)
		return
	}

	if *resetSddm {
		assertRoot()
		createFile(SDDM_XSETUP_PATH, SDDM_XSETUP_CONTENT, true)
		fmt.Println("Operation completed successfully")
		return
	}

	if *reset {
		assertRoot()
		cleanup()
		deleteCacheFile()
		rebuildInitramfs()
		fmt.Println("Operation completed successfully")
		return
	}

	flag.Usage()
}

func assertRoot() {
	if os.Geteuid() != 0 {
		log.Fatal("This operation requires root privileges")
	}
}

func logInfo(msg string) {
	if verbose {
		log.Printf("INFO: %s", msg)
	}
}

func logError(msg string) {
	log.Printf("ERROR: %s", msg)
}

func logWarning(msg string) {
	log.Printf("WARNING: %s", msg)
}

func graphicsModeSwitcher(config *Config) {
	fmt.Printf("Switching to %s mode
", config.Mode)

	switch config.Mode {
	case "integrated":
		handleIntegratedMode()
	case "hybrid":
		handleHybridMode(config)
	case "nvidia":
		handleNvidiaMode(config)
	default:
		log.Fatalf("Unsupported mode: %s", config.Mode)
	}

	fmt.Println("Operation completed successfully")
	fmt.Println("Please reboot your computer for changes to take effect!")
}

func handleIntegratedMode() {
	disableNvidiaService()
	cleanup()
	createFile(BLACKLIST_PATH, BLACKLIST_CONTENT, false)
	createFile(UDEV_INTEGRATED_PATH, UDEV_INTEGRATED, false)
	rebuildInitramfs()
}

func handleHybridMode(config *Config) {
	rtd3Value := 0
	if config.RTD3 != nil {
		rtd3Value = *config.RTD3
	}
	fmt.Printf("Enable PCI-Express Runtime D3 (RTD3) Power Management: %t
", config.RTD3 != nil)

	cleanup()
	enableNvidiaService()

	if config.RTD3 == nil {
		if config.UseNvidiaCurrent {
			createFile(MODESET_PATH, MODESET_CURRENT_CONTENT, false)
		} else {
			createFile(MODESET_PATH, MODESET_CONTENT, false)
		}
	} else {
		if config.UseNvidiaCurrent {
			createFile(MODESET_PATH, fmt.Sprintf(MODESET_CURRENT_RTD3, rtd3Value), false)
		} else {
			createFile(MODESET_PATH, fmt.Sprintf(MODESET_RTD3, rtd3Value), false)
		}
		createFile(UDEV_PM_PATH, UDEV_PM_CONTENT, false)
	}

	rebuildInitramfs()
}

func handleNvidiaMode(config *Config) {
	fmt.Printf("Enable ForceCompositionPipeline: %t
", config.ForceComp)
	coolbitsValue := 0
	if config.Coolbits != nil {
		coolbitsValue = *config.Coolbits
	}
	fmt.Printf("Enable Coolbits: %t
", config.Coolbits != nil)

	enableNvidiaService()
	cleanup()

	// Get NVIDIA GPU PCI bus
	nvidiaPCIBus := getNvidiaGPUPCIBus()
	config.NvidiaGPUPCIBus = nvidiaPCIBus

	// Get iGPU vendor
	igpuVendor := getIGPUVendor()

	// Create Xorg config
	var xorgContent string
	if igpuVendor == "intel" {
		xorgContent = fmt.Sprintf(XORG_INTEL, nvidiaPCIBus)
	} else if igpuVendor == "amd" {
		xorgContent = fmt.Sprintf(XORG_AMD, nvidiaPCIBus)
	}
	createFile(XORG_PATH, xorgContent, false)

	// Enable modeset for NVIDIA driver
	if config.UseNvidiaCurrent {
		createFile(MODESET_PATH, MODESET_CURRENT_CONTENT, false)
	} else {
		createFile(MODESET_PATH, MODESET_CONTENT, false)
	}

	// Extra Xorg config
	if config.ForceComp && config.Coolbits != nil {
		extraContent := EXTRA_XORG_CONTENT + FORCE_COMP + fmt.Sprintf(COOLBITS, coolbitsValue) + "EndSection
"
		createFile(EXTRA_XORG_PATH, extraContent, false)
	} else if config.ForceComp {
		extraContent := EXTRA_XORG_CONTENT + FORCE_COMP + "EndSection
"
		createFile(EXTRA_XORG_PATH, extraContent, false)
	} else if config.Coolbits != nil {
		extraContent := EXTRA_XORG_CONTENT + fmt.Sprintf(COOLBITS, coolbitsValue) + "EndSection
"
		createFile(EXTRA_XORG_PATH, extraContent, false)
	}

	// Display manager configuration
	displayManager := config.DisplayManager
	if displayManager == "" {
		displayManager = getDisplayManager()
	}

	if displayManager == "sddm" {
		// Backup Xsetup
		if fileExists(SDDM_XSETUP_PATH) {
			logInfo("Creating Xsetup backup")
			if content, err := os.ReadFile(SDDM_XSETUP_PATH); err == nil {
				createFile(SDDM_XSETUP_PATH+".bak", string(content), false)
			}
		}
		createFile(SDDM_XSETUP_PATH, generateXrandrScript(igpuVendor), true)
	} else if displayManager == "lightdm" {
		createFile(LIGHTDM_SCRIPT_PATH, generateXrandrScript(igpuVendor), true)
		createFile(LIGHTDM_CONFIG_PATH, LIGHTDM_CONFIG_CONTENT, false)
	}

	rebuildInitramfs()
}

func enableNvidiaService() {
	var cmd *exec.Cmd
	if verbose {
		cmd = exec.Command("systemctl", "enable", "nvidia-persistenced.service")
	} else {
		cmd = exec.Command("systemctl", "enable", "nvidia-persistenced.service")
		cmd.Stdout = nil
		cmd.Stderr = nil
	}

	if err := cmd.Run(); err == nil {
		fmt.Println("Successfully enabled nvidia-persistenced.service")
	} else {
		logError("An error occurred while enabling service")
	}
}

func disableNvidiaService() {
	var cmd *exec.Cmd
	if verbose {
		cmd = exec.Command("systemctl", "disable", "nvidia-persistenced.service")
	} else {
		cmd = exec.Command("systemctl", "disable", "nvidia-persistenced.service")
		cmd.Stdout = nil
		cmd.Stderr = nil
	}

	if err := cmd.Run(); err == nil {
		fmt.Println("Successfully disabled nvidia-persistenced.service")
	} else {
		logError("An error occurred while disabling service")
	}
}

func cleanup() {
	filesToRemove := []string{
		BLACKLIST_PATH,
		UDEV_INTEGRATED_PATH,
		UDEV_PM_PATH,
		XORG_PATH,
		EXTRA_XORG_PATH,
		MODESET_PATH,
		LIGHTDM_SCRIPT_PATH,
		LIGHTDM_CONFIG_PATH,
		// Legacy files
		"/etc/X11/xorg.conf.d/90-nvidia.conf",
		"/lib/udev/rules.d/50-remove-nvidia.rules",
		"/lib/udev/rules.d/80-nvidia-pm.rules",
	}

	for _, filePath := range filesToRemove {
		if fileExists(filePath) {
			if err := os.Remove(filePath); err != nil {
				logError(fmt.Sprintf("Failed to remove file '%s': %v", filePath, err))
			} else {
				logInfo(fmt.Sprintf("Removed file %s", filePath))
			}
		}
	}

	// Restore Xsetup backup if found
	backupPath := SDDM_XSETUP_PATH + ".bak"
	if fileExists(backupPath) {
		logInfo("Restoring Xsetup backup")
		if content, err := os.ReadFile(backupPath); err == nil {
			createFile(SDDM_XSETUP_PATH, string(content), false)
		}
		os.Remove(backupPath)
		logInfo(fmt.Sprintf("Removed file %s", backupPath))
	}
}

func getNvidiaGPUPCIBus() string {
	// Try to use cached value first
	if cache := readCacheFile(); cache != nil { // This line will cause a compile error until readCacheFile is defined
		return cache.NvidiaGPUPCIBus
	}

	cmd := exec.Command("lspci")
	output, err := cmd.Output()
	if err != nil {
		logError("Could not run lspci command")
		os.Exit(1)
	}

	lines := strings.Split(string(output), "
")
	for _, line := range lines {
		if strings.Contains(line, "NVIDIA") &&
			(strings.Contains(line, "VGA compatible controller") || strings.Contains(line, "3D controller")) {

			parts := strings.Fields(line)
			if len(parts) > 0 {
				pciBusID := parts[0]
				pciBusID = strings.Replace(pciBusID, "0000:", "", 1)
				logInfo(fmt.Sprintf("Found Nvidia GPU at %s", pciBusID))

				// Convert to PCI:bus:device:function format
				busParts := strings.Split(pciBusID, ":")
				if len(busParts) >= 2 {
					bus := busParts[0]
					deviceFunction := busParts[1]
					deviceParts := strings.Split(deviceFunction, ".")
					if len(deviceParts) >= 2 {
						device := deviceParts[0]
						function := deviceParts[1]

						// Convert from hex to decimal
						busInt, _ := strconv.ParseInt(bus, 16, 32)
						deviceInt, _ := strconv.ParseInt(device, 16, 32)
						functionInt, _ := strconv.ParseInt(function, 16, 32)

						return fmt.Sprintf("PCI:%d:%d:%d", busInt, deviceInt, functionInt)
					}
				}
			}
		}
	}

	logError("Could not find Nvidia GPU")
	fmt.Println("Try switching to hybrid mode first!")
	os.Exit(1)
	return ""
}

func getIGPUVendor() string {
	cmd := exec.Command("lspci")
	output, err := cmd.Output()
	if err != nil {
		logWarning("Could not run lspci command")
		return ""
	}

	lines := strings.Split(string(output), "
")
	for _, line := range lines {
		if strings.Contains(line, "VGA compatible controller") || strings.Contains(line, "Display controller") {
			if strings.Contains(line, "Intel") {
				logInfo("Found Intel iGPU")
				return "intel"
			} else if strings.Contains(line, "ATI") || strings.Contains(line, "AMD") || strings.Contains(line, "AMD/ATI") {
				logInfo("Found AMD iGPU")
				return "amd"
			}
		}
	}

	logWarning("Could not find Intel or AMD iGPU")
	return ""
}

func getDisplayManager() string {
	content, err := os.ReadFile("/etc/systemd/system/display-manager.service")
	if err != nil {
		logWarning("Display Manager detection is not available")
		return ""
	}

	re := regexp.MustCompile(` + "`" + `ExecStart=(.+)
` + "`" + `)
	matches := re.FindStringSubmatch(string(content))
	if len(matches) > 1 {
		displayManager := filepath.Base(matches[1])
		logInfo(fmt.Sprintf("Found %s Display Manager", displayManager))
		return displayManager
	}

	return ""
}

func generateXrandrScript(igpuVendor string) string {
	switch igpuVendor {
	case "intel":
		return fmt.Sprintf(NVIDIA_XRANDR_SCRIPT, "modesetting")
	case "amd":
		amdName := getAMDIGPUName()
		if amdName != "" {
			return fmt.Sprintf(NVIDIA_XRANDR_SCRIPT, amdName)
		}
		return fmt.Sprintf(NVIDIA_XRANDR_SCRIPT, "modesetting")
	default:
		return fmt.Sprintf(NVIDIA_XRANDR_SCRIPT, "modesetting")
	}
}

func getAMDIGPUName() string {
	if !fileExists("/usr/bin/xrandr") {
		logWarning("The 'xrandr' command is not available. Make sure the package is installed!")
		return ""
	}

	cmd := exec.Command("xrandr", "--listproviders")
	output, err := cmd.Output()
	if err != nil {
		logWarning("Failed to run the 'xrandr' command.")
		return ""
	}

	re := regexp.MustCompile(` + "`" + `(name:).*(ATI*|AMD*|AMD\/ATI)*` + "`" + `)
	matches := re.FindStringSubmatch(string(output))
	if len(matches) > 0 {
		return matches[0][5:] // Remove "name:" prefix
	}

	logWarning("Could not find AMD iGPU in 'xrandr' output.")
	return ""
}

func rebuildInitramfs() {
	var command []string

	// Detect system type and choose appropriate command
	if fileExists("/ostree") || fileExists("/sysroot/ostree") {
		fmt.Println("Rebuilding the initramfs with rpm-ostree...")
		command = []string{"rpm-ostree", "initramfs", "--enable", "--arg=--force"}
	} else if fileExists("/etc/debian_version") {
		command = []string{"update-initramfs", "-u", "-k", "all"}
	} else if fileExists("/etc/redhat-release") || fileExists("/usr/bin/zypper") {
		command = []string{"dracut", "--force", "--regenerate-all"}
	} else if fileExists("/usr/lib/endeavouros-release") && fileExists("/usr/bin/dracut") {
		command = []string{"dracut-rebuild"}
	} else if fileExists("/etc/altlinux-release") {
		command = []string{"make-initrd"}
	} else if fileExists("/etc/arch-release") {
		command = []string{"mkinitcpio", "-P"}
	}

	if len(command) == 0 {
		return
	}

	fmt.Println("Rebuilding the initramfs...")
	cmd := exec.Command(command[0], command[1:]...)
	if !verbose {
		cmd.Stdout = nil
		cmd.Stderr = nil
	}

	if err := cmd.Run(); err == nil {
		fmt.Println("Successfully rebuilt the initramfs!")
	} else {
		logError("An error occurred while rebuilding the initramfs")
	}
}

func createFile(path, content string, executable bool) {
	// Create parent directories if needed
	if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
		logError(fmt.Sprintf("Failed to create directories for '%s': %v", path, err))
		return
	}

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		logError(fmt.Sprintf("Failed to create file '%s': %v", path, err))
		return
	}

	logInfo(fmt.Sprintf("Created file %s", path))
	if verbose {
		fmt.Print(content)
	}

	if executable {
		if err := os.Chmod(path, 0755); err != nil {
			logError(fmt.Sprintf("Failed to set executable permission on '%s': %v", path, err))
		} else {
			logInfo(fmt.Sprintf("Added execution privilege to file %s", path))
		}
	}
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return !os.IsNotExist(err)
}

func getCurrentMode() string {
	if fileExists(BLACKLIST_PATH) &&
		(fileExists(UDEV_INTEGRATED_PATH) || fileExists("/lib/udev/rules.d/50-remove-nvidia.rules")) {
		return "integrated"
	} else if fileExists(XORG_PATH) && fileExists(MODESET_PATH) {
		return "nvidia"
	}
	return "hybrid"
}

// Cache management functions
func readCacheFile() *CacheData {
	if !fileExists(CACHE_FILE_PATH) {
		logInfo(fmt.Sprintf("Cache file not found at %s", CACHE_FILE_PATH))
		return nil
	}

	data, err := os.ReadFile(CACHE_FILE_PATH)
	if err != nil {
		logError(fmt.Sprintf("Failed to read cache file '%s': %v", CACHE_FILE_PATH, err))
		return nil
	}

	var cache CacheData
	if err := json.Unmarshal(data, &cache); err != nil {
		logError(fmt.Sprintf("Failed to unmarshal cache data from '%s': %v", CACHE_FILE_PATH, err))
		return nil
	}

	logInfo(fmt.Sprintf("Successfully read cache file %s", CACHE_FILE_PATH))
	return &cache
}

func createCacheFile() {
	currentMode := getCurrentMode()
	if currentMode != "hybrid" {
		log.Fatal("--cache-create requires that the system be in the hybrid Optimus mode")
	}

	nvidiaPCIBus := getNvidiaGPUPCIBus()
	cache := &CacheData{
		NvidiaGPUPCIBus: nvidiaPCIBus,
	}

	if err := os.MkdirAll(filepath.Dir(CACHE_FILE_PATH), 0755); err != nil {
		log.Fatalf("Failed to create cache directory: %v", err)
	}

	data, err := json.MarshalIndent(cache, "", "    ")
	if err != nil {
		log.Fatalf("Failed to marshal cache data: %v", err)
	}

	if err := os.WriteFile(CACHE_FILE_PATH, data, 0644); err != nil {
		log.Fatalf("Failed to write cache file: %v", err)
	}
}

// Placeholder for deleteCacheFile
func deleteCacheFile() {
	if !fileExists(CACHE_FILE_PATH) {
		logInfo(fmt.Sprintf("Cache file not found at %s. Nothing to delete.", CACHE_FILE_PATH))
		return
	}

	err := os.Remove(CACHE_FILE_PATH)
	if err != nil {
		logError(fmt.Sprintf("Failed to delete cache file '%s': %v", CACHE_FILE_PATH, err))
		return
	}

	logInfo(fmt.Sprintf("Successfully deleted cache file %s", CACHE_FILE_PATH))
	fmt.Println("Successfully deleted cache file.")
}

// Placeholder for showCacheFile
func showCacheFile() {
	if !fileExists(CACHE_FILE_PATH) {
		fmt.Printf("Cache file not found at %s
", CACHE_FILE_PATH)
		return
	}

	data, err := os.ReadFile(CACHE_FILE_PATH)
	if err != nil {
		logError(fmt.Sprintf("Failed to read cache file '%s': %v", CACHE_FILE_PATH, err))
		fmt.Println("Error reading cache file.")
		return
	}

	fmt.Println("Cache file content:")
	fmt.Println(string(data))
}
